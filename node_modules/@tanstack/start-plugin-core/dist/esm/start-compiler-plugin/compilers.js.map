{"version":3,"file":"compilers.js","sources":["../../../src/start-compiler-plugin/compilers.ts"],"sourcesContent":["import * as babel from '@babel/core'\nimport * as t from '@babel/types'\n\nimport {\n  deadCodeElimination,\n  findReferencedIdentifiers,\n} from 'babel-dead-code-elimination'\nimport { generateFromAst, parseAst } from '@tanstack/router-utils'\nimport { handleCreateMiddleware } from '../create-server-fn-plugin/handleCreateMiddleware'\nimport { transformFuncs } from './constants'\nimport { handleCreateIsomorphicFnCallExpression } from './isomorphicFn'\nimport {\n  handleCreateClientOnlyFnCallExpression,\n  handleCreateServerOnlyFnCallExpression,\n} from './envOnly'\nimport type { GeneratorResult, ParseAstOptions } from '@tanstack/router-utils'\n\nexport type CompileStartFrameworkOptions = 'react' | 'solid'\n\ntype Identifiers = { [K in (typeof transformFuncs)[number]]: IdentifierConfig }\n\nexport function compileStartOutputFactory(\n  framework: CompileStartFrameworkOptions,\n) {\n  return function compileStartOutput(opts: CompileOptions): GeneratorResult {\n    const identifiers: Partial<Identifiers> = {\n      createServerOnlyFn: {\n        name: 'createServerOnlyFn',\n        handleCallExpression: handleCreateServerOnlyFnCallExpression,\n        paths: [],\n      },\n      createClientOnlyFn: {\n        name: 'createClientOnlyFn',\n        handleCallExpression: handleCreateClientOnlyFnCallExpression,\n        paths: [],\n      },\n      createIsomorphicFn: {\n        name: 'createIsomorphicFn',\n        handleCallExpression: handleCreateIsomorphicFnCallExpression,\n        paths: [],\n      },\n    }\n\n    // createMiddleware only performs modifications in the client environment\n    // so we can avoid executing this on the server\n    if (opts.env === 'client') {\n      identifiers.createMiddleware = {\n        name: 'createMiddleware',\n        handleCallExpression: handleCreateMiddleware,\n        paths: [],\n      }\n    }\n\n    const ast = parseAst(opts)\n\n    const doDce = opts.dce ?? true\n    // find referenced identifiers *before* we transform anything\n    const refIdents = doDce ? findReferencedIdentifiers(ast) : undefined\n\n    const validImportSources = [\n      `@tanstack/${framework}-start`,\n      '@tanstack/start-client-core',\n    ]\n    babel.traverse(ast, {\n      Program: {\n        enter(programPath) {\n          programPath.traverse({\n            ImportDeclaration: (path) => {\n              if (!validImportSources.includes(path.node.source.value)) {\n                return\n              }\n\n              // handle a destructured imports being renamed like \"import { createServerFn as myCreateServerFn } from '@tanstack/react-start';\"\n              path.node.specifiers.forEach((specifier) => {\n                transformFuncs.forEach((identifierKey) => {\n                  const identifier = identifiers[identifierKey]\n                  if (!identifier) {\n                    return\n                  }\n                  if (\n                    specifier.type === 'ImportSpecifier' &&\n                    specifier.imported.type === 'Identifier'\n                  ) {\n                    if (specifier.imported.name === identifierKey) {\n                      identifier.name = specifier.local.name\n                    }\n                  }\n\n                  // handle namespace imports like \"import * as TanStackStart from '@tanstack/react-start';\"\n                  if (specifier.type === 'ImportNamespaceSpecifier') {\n                    identifier.name = `${specifier.local.name}.${identifierKey}`\n                  }\n                })\n              })\n            },\n            CallExpression: (path) => {\n              transformFuncs.forEach((identifierKey) => {\n                const identifier = identifiers[identifierKey]\n                if (!identifier) {\n                  return\n                }\n                // Check to see if the call expression is a call to the\n                // identifiers[identifierKey].name\n                if (\n                  t.isIdentifier(path.node.callee) &&\n                  path.node.callee.name === identifier.name\n                ) {\n                  // The identifier could be a call to the original function\n                  // in the source code. If this is case, we need to ignore it.\n                  // Check the scope to see if the identifier is a function declaration.\n                  // if it is, then we can ignore it.\n\n                  if (\n                    path.scope.getBinding(identifier.name)?.path.node.type ===\n                    'FunctionDeclaration'\n                  ) {\n                    return\n                  }\n\n                  return identifier.paths.push(path)\n                }\n\n                // handle namespace imports like \"import * as TanStackStart from '@tanstack/react-start';\"\n                // which are then called like \"TanStackStart.createServerFn()\"\n                if (t.isMemberExpression(path.node.callee)) {\n                  if (\n                    t.isIdentifier(path.node.callee.object) &&\n                    t.isIdentifier(path.node.callee.property)\n                  ) {\n                    const callname = [\n                      path.node.callee.object.name,\n                      path.node.callee.property.name,\n                    ].join('.')\n\n                    if (callname === identifier.name) {\n                      identifier.paths.push(path)\n                    }\n                  }\n                }\n\n                return\n              })\n            },\n          })\n\n          transformFuncs.forEach((identifierKey) => {\n            const identifier = identifiers[identifierKey]\n            if (!identifier) {\n              return\n            }\n            identifier.paths.forEach((path) => {\n              identifier.handleCallExpression(\n                path as babel.NodePath<t.CallExpression>,\n                opts,\n              )\n            })\n          })\n        },\n      },\n    })\n\n    if (doDce) {\n      deadCodeElimination(ast, refIdents)\n    }\n\n    return generateFromAst(ast, {\n      sourceMaps: true,\n      sourceFileName: opts.filename,\n      filename: opts.filename,\n    })\n  }\n}\n\nexport type CompileOptions = ParseAstOptions & {\n  env: 'server' | 'client'\n  dce?: boolean\n  filename: string\n}\n\nexport type IdentifierConfig = {\n  name: string\n  handleCallExpression: (\n    path: babel.NodePath<t.CallExpression>,\n    opts: CompileOptions,\n  ) => void\n  paths: Array<babel.NodePath>\n}\n"],"names":[],"mappings":"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"}
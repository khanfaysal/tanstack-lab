{"version":3,"file":"index.cjs","sources":["../../src/index.ts"],"sourcesContent":["import { fileURLToPath, pathToFileURL } from 'node:url'\n\nimport { logDiff } from '@tanstack/router-utils'\nimport { compileDirectives } from './compilers'\nimport type {\n  CompileDirectivesOpts,\n  DirectiveFn,\n  GenerateFunctionIdFn,\n} from './compilers'\nimport type { Plugin } from 'vite'\n\nconst debug =\n  process.env.TSR_VITE_DEBUG &&\n  ['true', 'directives-functions-plugin'].includes(process.env.TSR_VITE_DEBUG)\n\nexport type {\n  DirectiveFn,\n  CompileDirectivesOpts,\n  ReplacerFn,\n  GenerateFunctionIdFn,\n} from './compilers'\n\nexport type DirectiveFunctionsViteEnvOptions = Pick<\n  CompileDirectivesOpts,\n  'getRuntimeCode' | 'replacer'\n>\nexport type DirectiveFunctionsViteOptions = DirectiveFunctionsViteEnvOptions & {\n  directive: string\n  onDirectiveFnsById?: (directiveFnsById: Record<string, DirectiveFn>) => void\n  generateFunctionId: GenerateFunctionIdFn\n}\n\nconst createDirectiveRx = (directive: string) =>\n  new RegExp(`\"${directive}\"|'${directive}'`, 'gm')\n\nexport type DirectiveFunctionsVitePluginEnvOptions = {\n  directive: string\n  callers: Array<DirectiveFunctionsViteEnvOptions & { envName: string }>\n  provider: DirectiveFunctionsViteEnvOptions & { envName: string }\n  onDirectiveFnsById?: (directiveFnsById: Record<string, DirectiveFn>) => void\n  generateFunctionId: GenerateFunctionIdFn\n}\n\nfunction buildDirectiveSplitParam(directive: string) {\n  return `tsr-directive-${directive.replace(/[^a-zA-Z0-9]/g, '-')}`\n}\n\nexport function TanStackDirectiveFunctionsPluginEnv(\n  opts: DirectiveFunctionsVitePluginEnvOptions,\n): Plugin {\n  let root: string = process.cwd()\n\n  const directiveRx = createDirectiveRx(opts.directive)\n\n  const appliedEnvironments = new Set([\n    ...opts.callers.map((c) => c.envName),\n    opts.provider.envName,\n  ])\n\n  const directiveSplitParam = buildDirectiveSplitParam(opts.directive)\n\n  return {\n    name: 'tanstack-start-directive-vite-plugin',\n    enforce: 'pre',\n    buildStart() {\n      root = this.environment.config.root\n    },\n    applyToEnvironment(env) {\n      return appliedEnvironments.has(env.name)\n    },\n    transform: {\n      filter: {\n        code: directiveRx,\n      },\n      handler(code, id) {\n        const url = pathToFileURL(id)\n        url.searchParams.delete('v')\n        id = fileURLToPath(url).replace(/\\\\/g, '/')\n\n        const isDirectiveSplitParam = id.includes(directiveSplitParam)\n\n        let envOptions: DirectiveFunctionsViteEnvOptions & { envName: string }\n        if (isDirectiveSplitParam) {\n          envOptions = opts.provider\n          if (debug)\n            console.info(\n              `Compiling Directives for provider in environment ${envOptions.envName}: `,\n              id,\n            )\n        } else {\n          envOptions = opts.callers.find(\n            (e) => e.envName === this.environment.name,\n          )!\n          if (debug)\n            console.info(\n              `Compiling Directives for caller in environment ${envOptions.envName}: `,\n              id,\n            )\n        }\n        const { compiledResult, directiveFnsById } = compileDirectives({\n          directive: opts.directive,\n          getRuntimeCode: envOptions.getRuntimeCode,\n          generateFunctionId: opts.generateFunctionId,\n          replacer: envOptions.replacer,\n          code,\n          root,\n          filename: id,\n          directiveSplitParam,\n          isDirectiveSplitParam,\n        })\n        // when we process a file with a directive split param, we have already encountered the directives in that file\n        // (otherwise we wouldn't have gotten here)\n        if (!isDirectiveSplitParam) {\n          opts.onDirectiveFnsById?.(directiveFnsById)\n        }\n\n        if (debug) {\n          logDiff(code, compiledResult.code)\n          console.log('Output:\\n', compiledResult.code + '\\n\\n')\n        }\n\n        return compiledResult\n      },\n    },\n  }\n}\n"],"names":["pathToFileURL","fileURLToPath","compileDirectives","logDiff"],"mappings":";;;;;AAWA,MAAM,QACJ,QAAQ,IAAI,kBACZ,CAAC,QAAQ,6BAA6B,EAAE,SAAS,QAAQ,IAAI,cAAc;AAmB7E,MAAM,oBAAoB,CAAC,cACzB,IAAI,OAAO,IAAI,SAAS,MAAM,SAAS,KAAK,IAAI;AAUlD,SAAS,yBAAyB,WAAmB;AACnD,SAAO,iBAAiB,UAAU,QAAQ,iBAAiB,GAAG,CAAC;AACjE;AAEO,SAAS,oCACd,MACQ;AACR,MAAI,OAAe,QAAQ,IAAA;AAE3B,QAAM,cAAc,kBAAkB,KAAK,SAAS;AAEpD,QAAM,0CAA0B,IAAI;AAAA,IAClC,GAAG,KAAK,QAAQ,IAAI,CAAC,MAAM,EAAE,OAAO;AAAA,IACpC,KAAK,SAAS;AAAA,EAAA,CACf;AAED,QAAM,sBAAsB,yBAAyB,KAAK,SAAS;AAEnE,SAAO;AAAA,IACL,MAAM;AAAA,IACN,SAAS;AAAA,IACT,aAAa;AACX,aAAO,KAAK,YAAY,OAAO;AAAA,IACjC;AAAA,IACA,mBAAmB,KAAK;AACtB,aAAO,oBAAoB,IAAI,IAAI,IAAI;AAAA,IACzC;AAAA,IACA,WAAW;AAAA,MACT,QAAQ;AAAA,QACN,MAAM;AAAA,MAAA;AAAA,MAER,QAAQ,MAAM,IAAI;AAChB,cAAM,MAAMA,SAAAA,cAAc,EAAE;AAC5B,YAAI,aAAa,OAAO,GAAG;AAC3B,aAAKC,SAAAA,cAAc,GAAG,EAAE,QAAQ,OAAO,GAAG;AAE1C,cAAM,wBAAwB,GAAG,SAAS,mBAAmB;AAE7D,YAAI;AACJ,YAAI,uBAAuB;AACzB,uBAAa,KAAK;AAClB,cAAI;AACF,oBAAQ;AAAA,cACN,oDAAoD,WAAW,OAAO;AAAA,cACtE;AAAA,YAAA;AAAA,QAEN,OAAO;AACL,uBAAa,KAAK,QAAQ;AAAA,YACxB,CAAC,MAAM,EAAE,YAAY,KAAK,YAAY;AAAA,UAAA;AAExC,cAAI;AACF,oBAAQ;AAAA,cACN,kDAAkD,WAAW,OAAO;AAAA,cACpE;AAAA,YAAA;AAAA,QAEN;AACA,cAAM,EAAE,gBAAgB,iBAAA,IAAqBC,4BAAkB;AAAA,UAC7D,WAAW,KAAK;AAAA,UAChB,gBAAgB,WAAW;AAAA,UAC3B,oBAAoB,KAAK;AAAA,UACzB,UAAU,WAAW;AAAA,UACrB;AAAA,UACA;AAAA,UACA,UAAU;AAAA,UACV;AAAA,UACA;AAAA,QAAA,CACD;AAGD,YAAI,CAAC,uBAAuB;AAC1B,eAAK,qBAAqB,gBAAgB;AAAA,QAC5C;AAEA,YAAI,OAAO;AACTC,8BAAQ,MAAM,eAAe,IAAI;AACjC,kBAAQ,IAAI,aAAa,eAAe,OAAO,MAAM;AAAA,QACvD;AAEA,eAAO;AAAA,MACT;AAAA,IAAA;AAAA,EACF;AAEJ;;"}